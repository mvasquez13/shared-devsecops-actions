name: 'Deploy to Kubernetes'
description: 'Deploy application to Kubernetes cluster with security best practices'

inputs:
  registry:
    description: 'Container registry URL'
    required: true
  image-name:
    description: 'Docker image name'
    required: true
  image-tag:
    description: 'Docker image tag'
    required: true
  kubeconfig:
    description: 'Kubernetes configuration'
    required: true
  namespace:
    description: 'Kubernetes namespace'
    required: false
    default: 'default'
  app-name:
    description: 'Application name'
    required: true
  app-port:
    description: 'Application port'
    required: false
    default: '8080'
  replicas:
    description: 'Number of replicas'
    required: false
    default: '2'
  ingress-enabled:
    description: 'Enable ingress'
    required: false
    default: 'false'
  ingress-host:
    description: 'Ingress hostname'
    required: false
  health-check-path:
    description: 'Health check endpoint'
    required: false
    default: '/actuator/health'

outputs:
  deployment-url:
    description: 'Deployment URL'
    value: ${{ steps.deploy.outputs.url }}
  service-ip:
    description: 'Service external IP'
    value: ${{ steps.deploy.outputs.service-ip }}

runs:
  using: 'composite'
  steps:
    - name: Setup Kubernetes
      shell: bash
      run: |
        echo "☸️ Setting up Kubernetes deployment..."
        
        # Setup kubectl
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/
        
        # Setup kubeconfig
        mkdir -p ~/.kube
        echo '${{ inputs.kubeconfig }}' | base64 -d > ~/.kube/config
        chmod 600 ~/.kube/config
        
        # Verify connection
        kubectl cluster-info
        
        echo "✅ Kubernetes setup completed"

    - name: Create Namespace
      shell: bash
      run: |
        echo "📁 Creating namespace: ${{ inputs.namespace }}"
        
        # Create namespace if it doesn't exist
        kubectl create namespace ${{ inputs.namespace }} --dry-run=client -o yaml | kubectl apply -f -
        
        # Set as default namespace for subsequent commands
        kubectl config set-context --current --namespace=${{ inputs.namespace }}

    - name: Generate Kubernetes Manifests
      shell: bash
      run: |
        echo "📝 Generating Kubernetes manifests..."
        
        mkdir -p k8s-manifests
        
        # Generate Deployment
        cat > k8s-manifests/deployment.yaml << EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${{ inputs.app-name }}
  namespace: ${{ inputs.namespace }}
  labels:
    app: ${{ inputs.app-name }}
    version: "${{ inputs.image-tag }}"
spec:
  replicas: ${{ inputs.replicas }}
  selector:
    matchLabels:
      app: ${{ inputs.app-name }}
  template:
    metadata:
      labels:
        app: ${{ inputs.app-name }}
        version: "${{ inputs.image-tag }}"
    spec:
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        fsGroup: 1000
      containers:
      - name: ${{ inputs.app-name }}
        image: ${{ inputs.registry }}/${{ inputs.image-name }}:${{ inputs.image-tag }}
        ports:
        - containerPort: ${{ inputs.app-port }}
          name: http
        env:
        - name: JAVA_OPTS
          value: "-Xmx512m -Xms256m"
        - name: SPRING_PROFILES_ACTIVE
          value: "prod"
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL
        livenessProbe:
          httpGet:
            path: ${{ inputs.health-check-path }}
            port: ${{ inputs.app-port }}
          initialDelaySeconds: 60
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: ${{ inputs.health-check-path }}
            port: ${{ inputs.app-port }}
          initialDelaySeconds: 30
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
        volumeMounts:
        - name: tmp
          mountPath: /tmp
      volumes:
      - name: tmp
        emptyDir: {}
      imagePullSecrets:
      - name: registry-secret
EOF
        
        # Generate Service
        cat > k8s-manifests/service.yaml << EOF
apiVersion: v1
kind: Service
metadata:
  name: ${{ inputs.app-name }}
  namespace: ${{ inputs.namespace }}
  labels:
    app: ${{ inputs.app-name }}
spec:
  type: ClusterIP
  ports:
  - port: 80
    targetPort: ${{ inputs.app-port }}
    name: http
  selector:
    app: ${{ inputs.app-name }}
EOF
        
        # Generate Ingress if enabled
        if [ "${{ inputs.ingress-enabled }}" = "true" ]; then
          cat > k8s-manifests/ingress.yaml << EOF
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ${{ inputs.app-name }}
  namespace: ${{ inputs.namespace }}
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
spec:
  tls:
  - hosts:
    - ${{ inputs.ingress-host }}
    secretName: ${{ inputs.app-name }}-tls
  rules:
  - host: ${{ inputs.ingress-host }}
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: ${{ inputs.app-name }}
            port:
              number: 80
EOF
        fi
        
        # Generate NetworkPolicy
        cat > k8s-manifests/network-policy.yaml << EOF
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: ${{ inputs.app-name }}
  namespace: ${{ inputs.namespace }}
spec:
  podSelector:
    matchLabels:
      app: ${{ inputs.app-name }}
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: nginx-ingress
    ports:
    - protocol: TCP
      port: ${{ inputs.app-port }}
  egress:
  - to: []
    ports:
    - protocol: TCP
      port: 53
    - protocol: UDP
      port: 53
  - to: []
    ports:
    - protocol: TCP
      port: 443
    - protocol: TCP
      port: 80
EOF

    - name: Deploy to Kubernetes
      id: deploy
      shell: bash
      run: |
        echo "🚀 Deploying to Kubernetes..."
        
        # Apply manifests
        kubectl apply -f k8s-manifests/
        
        # Wait for deployment to be ready
        echo "⏳ Waiting for deployment to be ready..."
        kubectl rollout status deployment/${{ inputs.app-name }} --timeout=300s
        
        # Get service information
        SERVICE_IP=$(kubectl get service ${{ inputs.app-name }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || echo "")
        if [ -z "$SERVICE_IP" ]; then
          SERVICE_IP=$(kubectl get service ${{ inputs.app-name }} -o jsonpath='{.spec.clusterIP}')
        fi
        
        echo "service-ip=$SERVICE_IP" >> $GITHUB_OUTPUT
        
        # Determine deployment URL
        if [ "${{ inputs.ingress-enabled }}" = "true" ]; then
          DEPLOYMENT_URL="https://${{ inputs.ingress-host }}"
        else
          DEPLOYMENT_URL="http://$SERVICE_IP"
        fi
        
        echo "url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
        
        echo "✅ Deployment completed successfully!"
        echo "🔗 Application URL: $DEPLOYMENT_URL"

    - name: Run Health Check
      shell: bash
      run: |
        echo "🏥 Running health check..."
        
        # Get pod name
        POD_NAME=$(kubectl get pods -l app=${{ inputs.app-name }} -o jsonpath='{.items[0].metadata.name}')
        echo "Testing health check on pod: $POD_NAME"
        
        # Port forward and test
        kubectl port-forward $POD_NAME 8080:${{ inputs.app-port }} &
        PF_PID=$!
        
        # Wait a moment for port forward to establish
        sleep 5
        
        # Test health endpoint
        HEALTH_STATUS=$(curl -f -s http://localhost:8080${{ inputs.health-check-path }} || echo "FAILED")
        
        # Cleanup
        kill $PF_PID 2>/dev/null || true
        
        if [ "$HEALTH_STATUS" = "FAILED" ]; then
          echo "❌ Health check failed"
          exit 1
        else
          echo "✅ Health check passed"
          echo "Response: $HEALTH_STATUS"
        fi

    - name: Deployment Summary
      shell: bash
      run: |
        echo "📊 Deployment Summary"
        
        # Get deployment status
        kubectl get deployment ${{ inputs.app-name }} -o wide
        kubectl get pods -l app=${{ inputs.app-name }}
        kubectl get service ${{ inputs.app-name }}
        
        if [ "${{ inputs.ingress-enabled }}" = "true" ]; then
          kubectl get ingress ${{ inputs.app-name }}
        fi
        
        echo "## 🚀 Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "- **Application**: ${{ inputs.app-name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Namespace**: ${{ inputs.namespace }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Image**: ${{ inputs.registry }}/${{ inputs.image-name }}:${{ inputs.image-tag }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Replicas**: ${{ inputs.replicas }}" >> $GITHUB_STEP_SUMMARY
        echo "- **URL**: ${{ steps.deploy.outputs.url }}" >> $GITHUB_STEP_SUMMARY
        
        echo "🎉 Kubernetes deployment completed successfully!"